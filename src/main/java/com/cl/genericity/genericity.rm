泛型：
    ArrayList不适用泛型，默认就是使用Object类型；
    不适用泛型缺点：需要强制转化；很容易出现ClassCastException;
                 使用子类StringArrayList extends ArrayList;\\子类膨胀
    使用泛型优点：
        编写一次，供任意类型使用；
        编译时检查，避免ClassCastException;
        支持向上转型： List<String> = new ArrayList<String>
            注意：ArrayList<Integer>不可以转型为ArrayList<Number>,虽然Integer extends Number;但是前两者是没有继承关系的；如果发生这种转型就会导致ClassCastException;
            注意：泛型仅支持引用类型，不能支持基本类型；

    使用：
        编译器自动推导；
        泛型方法
        泛型类型
        泛型接口：

    编写泛型：
    // 不可以编译通过:
    public static Pair<T> create(T first, T last) {
        return new Pair<T>(first, last);
    }
    // 可以编译通过:
    public static <T> Pair<T> create(T first, T last) {
        return new Pair<T>(first, last);
    }
    注意： 静态方法里的泛型和泛型类声明的泛型无关；

    泛型通配符：extends super 无限制通配符
        <? extends T> 表示T和T的子类，可以? get(),不能set(?);
            void set(Pair<>)

        <? super T> 表示T和T的父类，可以set(?),不能get()；

        PECS原则：生产者（Producer）用上界，消费者（Consumer）用下界;
    泛型和反射：
        声明带泛型的数组不能new创建，必须通过强制转型；


